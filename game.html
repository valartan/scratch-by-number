<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Scratch by Number ‚Äì Jeu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- PWA / th√®me -->
  <meta name="theme-color" content="#fbe9f0" />

  <!-- PWA / manifest -->
  <link rel="manifest" href="manifest.webmanifest">

  <!-- iOS PWA -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="Scratch by Number">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: linear-gradient(135deg,#fbe9f0,#e5f0ff);
      min-height: 100vh;
      color: #333;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 16px;
    }
    #app {
      width: 100%;
      max-width: 480px;
      background: rgba(255,255,255,0.96);
      border-radius: 24px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.20);
      padding: 20px 18px 18px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    header { text-align: center; }
    .logoTitle {
      font-size: 22px;
      font-weight: 700;
      letter-spacing: .03em;
      color: #ff6fb5;
      text-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    .subtitle {
      font-size: 13px;
      color: #777;
      margin-top: 4px;
    }
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    section.screen {
      display: none;
      flex-direction: column;
      gap: 12px;
    }
    section.screen.active { display: flex; }

    .btn {
      width: 100%;
      padding: 12px 14px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      font-size: 15px;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.15s ease;
    }
    .btnPrimary {
      background: linear-gradient(135deg,#ff7ac4,#ff9c9c);
      color: white;
      box-shadow: 0 6px 16px rgba(255,122,196,0.45);
    }
    .btnPrimary:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 3px 10px rgba(255,122,196,0.4);
    }
    .btnSecondary {
      background: #f3f5ff;
      color: #4353a5;
      box-shadow: 0 4px 10px rgba(40,40,90,0.10);
    }
    .btnSecondary:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 2px 7px rgba(40,40,90,0.16);
    }
    .btn[disabled] {
      opacity: .4;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    .sectionTitle {
      font-weight: 600;
      font-size: 16px;
      margin-bottom: 4px;
    }
    .smallText { font-size: 13px; color: #777; }

    .card {
      border-radius: 18px;
      background: #f8f7ff;
      padding: 10px 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    }

    .globalProgressBar {
      width: 100%;
      height: 8px;
      background: #e0e4ff;
      border-radius: 999px;
      overflow: hidden;
      margin-top: 6px;
    }
    .globalProgressInner {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg,#6cc6ff,#a971ff);
      transition: width 0.2s ease;
    }
    .tag {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      font-size: 11px;
      padding: 3px 8px;
      background: rgba(255,255,255,0.8);
      color: #666;
      border: 1px solid rgba(0,0,0,0.04);
      margin-top: 4px;
    }

    .collectionList {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 360px;
      overflow-y: auto;
      padding-right: 4px;
    }
    .collectionCard {
      display: flex;
      align-items: center;
      padding: 10px 12px;
      border-radius: 16px;
      background: #f9f5ff;
      cursor: pointer;
      gap: 10px;
      box-shadow: 0 4px 10px rgba(90,60,160,0.08);
      transition: transform 0.1s ease, box-shadow 0.1s ease;
    }
    .collectionCard:hover {
      transform: translateY(-1px);
      box-shadow: 0 7px 16px rgba(90,60,160,0.12);
    }
    .collectionThumb {
      width: 48px;
      height: 48px;
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      background: linear-gradient(135deg,#ffd3e2,#c5d8ff);
    }
    .collectionInfo { flex: 1; }
    .collectionName { font-weight: 600; font-size: 15px; }
    .collectionMeta { font-size: 12px; color: #666; margin-top: 3px; }

    .levelsGrid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      max-height: 360px;
      overflow-y: auto;
      padding-right: 4px;
    }
    .levelCard {
      background: #f7f7ff;
      border-radius: 14px;
      padding: 6px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.06);
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.08s ease;
    }
    .levelCard:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(0,0,0,0.12);
    }
    .levelThumb {
      border-radius: 10px;
      background: linear-gradient(135deg,#ffd3e2,#c5d8ff);
      height: 70px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255,255,255,0.95);
      font-size: 12px;
      font-weight: 600;
      text-shadow: 0 1px 4px rgba(0,0,0,0.35);
      overflow: hidden;
    }
    .levelThumbCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .levelTitle { font-size: 12px; font-weight: 600; color: #444; }
    .levelStatus { font-size: 11px; color: #777; }

    .gameHeaderRow {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .gameTitleBlock {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .gameTitle {
      font-size: 15px;
      font-weight: 600;
    }
    .gameSubtitle {
      font-size: 12px;
      color: #777;
    }
    .gameStats {
      font-size: 12px;
      text-align: right;
      color: #555;
    }
    .gameCard {
      margin-top: 6px;
      border-radius: 20px;
      background: #f6f5ff;
      padding: 10px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    .gameCanvasWrap {
      border-radius: 18px;
      overflow: hidden;
      background: #000;
      width: 100%;
      max-width: 360px;
      aspect-ratio: 1 / 1;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #gameCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
      background: #000;
    }
    .brushRow {
      font-size: 12px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 4px;
      margin-top: 4px;
    }
    .brushRowInner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .brushLabel { font-size: 12px; color: #555; }
    .brushValue { font-weight: 600; font-size: 12px; }
    .brushSlider { width: 100%; }

    /* Palette horizontale scrollable propre */
    .paletteRow {
      display: flex;
      flex-direction: row;
      gap: 14px;
      padding: 10px;
      overflow-x: auto;
      overflow-y: hidden;
      max-width: 100%;
      box-sizing: border-box;
      scroll-behavior: smooth;
      scrollbar-width: none; /* Firefox */
    }
    .paletteRow::-webkit-scrollbar {
      display: none; /* Chrome / Safari */
    }
    .dot {
      width: 52px;
      height: 52px;
      border-radius: 50%;
      border: 4px solid #fff;
      box-shadow: 0 4px 10px rgba(0,0,0,0.15);
      position: relative;
      flex-shrink: 0;
      cursor: pointer;
      transition: transform 0.12s ease, box-shadow 0.12s ease, border 0.12s ease;
    }
    .dot.active {
      transform: scale(1.12);
      border-width: 4px;
      border-color: #ff7ac4;
      box-shadow: 0 0 12px rgba(255,255,255,0.8), 0 4px 14px rgba(0,0,0,0.25);
      animation: pulseDot 0.25s ease;
    }
    .dotCount {
      position: absolute;
      bottom: -6px;
      right: -6px;
      background: linear-gradient(135deg,#ff7ac4,#ff9c9c);
      color: #fff;
      font-size: 12px;
      padding: 3px 6px;
      border-radius: 12px;
      font-weight: 600;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }

    .backLink {
      font-size: 13px;
      color: #6874c8;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .backLink span { font-size: 16px; }

    @media (max-width: 520px) {
      #app {
        border-radius: 20px;
        padding: 16px 14px 14px;
      }
    }

    @keyframes pulseDot {
      0% { transform: scale(1); }
      50% { transform: scale(1.15); }
      100% { transform: scale(1); }
    }

    /* Pastille qui dispara√Æt en douceur */
    .dot.disappearing {
      animation: dotDisappear 0.55s ease forwards;
    }
    @keyframes dotDisappear {
      0% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
      60% {
        transform: scale(0.45) rotate(12deg);
        opacity: 0.6;
      }
      100% {
        transform: scale(0.1) rotate(25deg);
        opacity: 0;
      }
    }
  </style>
</head>

<body>
<div id="app">
  <header>
    <div class="logoTitle">Scratch by Number</div>
    <div class="subtitle">Gratte, r√©v√®le, d√©tends-toi ‚ú®</div>
  </header>

  <main>
    <!-- HOME SCREEN -->
    <section id="screen-home" class="screen active">
      <div class="sectionTitle">Bienvenue</div>
      <div class="card">
        <div class="smallText">
          Compl√®te des images cach√©es en grattant la surface, couleur par couleur.
        </div>
        <div style="margin-top:8px;font-size:13px;color:#555;">
          Progression globale : <span id="globalProgressLabel">0 / 0 images</span>
        </div>
        <div class="globalProgressBar">
          <div id="globalProgressInner" class="globalProgressInner"></div>
        </div>
        <div class="tag">Les niveaux viennent de /levels/levels.json (publi√©s via le Builder)</div>
      </div>

      <button id="btn-continue" class="btn btnPrimary" disabled>
        ‚ñ∂ Continuer
      </button>

      <button id="btn-daily" class="btn btnSecondary">
        üåû D√©fi du jour
      </button>

      <button id="btn-collections" class="btn btnSecondary">
        üìö Collections
      </button>
    </section>

    <!-- COLLECTIONS SCREEN -->
    <section id="screen-collections" class="screen">
      <div class="backLink" id="back-from-collections">
        <span>‚Üê</span> Retour
      </div>
      <div class="sectionTitle" style="margin-top:4px;">Collections</div>
      <div class="smallText">Choisis un th√®me d‚Äôimages √† gratter.</div>

      <div id="collectionsList" class="collectionList"></div>
    </section>

    <!-- LEVELS SCREEN -->
    <section id="screen-levels" class="screen">
      <div class="backLink" id="back-from-levels">
        <span>‚Üê</span> Collections
      </div>
      <div class="sectionTitle" id="levelsTitle" style="margin-top:4px;">Niveaux</div>
      <div class="smallText" id="levelsSubtitle"></div>

      <div id="levelsGrid" class="levelsGrid"></div>
    </section>

    <!-- GAME SCREEN -->
    <section id="screen-game" class="screen">
      <div class="backLink" id="back-from-game">
        <span>‚Üê</span> Niveaux
      </div>

      <div class="gameHeaderRow" style="margin-top:4px;">
        <div class="gameTitleBlock">
          <div class="gameTitle" id="gameTitle">Titre du niveau</div>
          <div class="gameSubtitle" id="gameSubtitle">Collection</div>
        </div>
        <div class="gameStats">
          <div>Progression : <span id="gameProgressPercent">0%</span></div>
          <div>Restants : <span id="gameRemaining">0</span></div>
        </div>
      </div>

      <div class="gameCard">
        <div class="gameCanvasWrap" style="position:relative;">
          <canvas id="gameCanvas" width="360" height="360" style="position:absolute; inset:0; width:100%; height:100%; touch-action:none; background:#000;"></canvas>
          <canvas id="gameCanvasScratch" width="360" height="360" style="position:absolute; inset:0; width:100%; height:100%; touch-action:none;"></canvas>
        </div>

        <div class="brushRow">
          <div class="brushRowInner">
            <div class="brushLabel">Taille du pinceau</div>
            <div class="brushValue"><span id="gameBrushVal">3</span> px</div>
          </div>
          <input id="gameBrushSlider" class="brushSlider" type="range" min="1" max="50" value="3">
        </div>

        <div class="paletteRow" id="gamePaletteRow"></div>
      </div>
    </section>
  </main>
</div>

<script>
  // =========================
  // HAPTIC / VIBRATION HELPER
  // =========================
  function triggerHaptic(level = "light") {
    try {
      if ("vibrate" in navigator) {
        if (level === "heavy") {
          navigator.vibrate(30);
        } else if (level === "medium") {
          navigator.vibrate(15);
        } else {
          navigator.vibrate(8);
        }
      }
      // iOS Safari ne supporte pas vibrate pour l'instant, mais Android oui.
    } catch (e) {
      console.warn("Haptic error", e);
    }
  }

  // =========================
  // STATE GLOBAL
  // =========================
  let LEVELS_DATA = { collections: [] };

  const screens = {
    home: document.getElementById("screen-home"),
    collections: document.getElementById("screen-collections"),
    levels: document.getElementById("screen-levels"),
    game: document.getElementById("screen-game")
  };

  function showScreen(name) {
    Object.values(screens).forEach(s => s.classList.remove("active"));
    if (screens[name]) screens[name].classList.add("active");
  }

  // --- progression globale
  function computeGlobalProgress() {
    const total = LEVELS_DATA.collections.reduce(
      (sum,c)=>sum + (c.levels?.length||0),
      0
    );
    let completed = 0;
    try {
      const raw = localStorage.getItem("sbn_completed_levels");
      if (raw){
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) completed = arr.length;
      }
    } catch{}
    if (completed>total) completed=total;
    return {completed,total};
  }
  function refreshGlobalProgressUI() {
    const {completed,total} = computeGlobalProgress();
    const label = document.getElementById("globalProgressLabel");
    const bar = document.getElementById("globalProgressInner");
    label.textContent = `${completed} / ${total} images`;
    let perc = total>0 ? (completed/total)*100 : 0;
    bar.style.width = perc + "%";
  }

  // --- last played
  function loadLastPlayed() {
    try {
      const raw = localStorage.getItem("sbn_last_level");
      if (!raw) return null;
      return JSON.parse(raw);
    } catch {return null;}
  }
  function saveLastPlayed(collectionId, levelId) {
    const obj = {collectionId,levelId,time:Date.now()};
    localStorage.setItem("sbn_last_level", JSON.stringify(obj));
  }
  function markLevelCompleted(levelId) {
    let arr=[];
    try {
      const raw=localStorage.getItem("sbn_completed_levels");
      if (raw) arr=JSON.parse(raw);
    } catch{}
    if (!Array.isArray(arr)) arr=[];
    if (!arr.includes(levelId)) arr.push(levelId);
    localStorage.setItem("sbn_completed_levels", JSON.stringify(arr));
  }
  function isLevelCompleted(levelId) {
    try {
      const raw = localStorage.getItem("sbn_completed_levels");
      if (!raw) return false;
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return false;
      return arr.includes(levelId);
    } catch {return false;}
  }
  function refreshContinueButton() {
    const btnContinue = document.getElementById("btn-continue");
    const last = loadLastPlayed();
    if (!last) { btnContinue.disabled = true; return; }
    btnContinue.disabled = false;
  }

  // =========================
  // SAUVEGARDE PAR NIVEAU
  // =========================
  function levelProgressKey(collectionId, levelId) {
    return `sbn_progress_${collectionId}_${levelId}`;
  }
  function loadLevelProgressData(collectionId, levelId) {
    const key = levelProgressKey(collectionId, levelId);
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (e) {
      console.warn("loadLevelProgressData error", e);
      return null;
    }
  }
  function saveLevelProgressData(payload) {
    if (!payload || !payload.collectionId || !payload.levelId) return;
    const key = levelProgressKey(payload.collectionId, payload.levelId);
    try {
      localStorage.setItem(key, JSON.stringify(payload));
    } catch(e) {
      console.warn("saveLevelProgressData error", e);
    }
  }

  // =========================
  // CHARGEMENT LEVELS.JSON
  // =========================
  async function loadLevelsConfig() {
    try {
      const res = await fetch("levels/levels.json");
      if (!res.ok) throw new Error("HTTP "+res.status);
      const data = await res.json();
      if (!data.collections) data.collections=[];
      LEVELS_DATA = data;
    } catch (e) {
      console.warn("Impossible de charger levels.json, aucune collection pour l‚Äôinstant.");
      LEVELS_DATA = { collections: [] };
    }
  }

  // =========================
  // HOME SCREEN
  // =========================
  const btnContinue = document.getElementById("btn-continue");
  const btnDaily = document.getElementById("btn-daily");
  const btnCollections = document.getElementById("btn-collections");

  btnCollections.addEventListener("click", () => {
    buildCollectionsList();
    showScreen("collections");
  });

  btnDaily.addEventListener("click", () => {
    const firstCol = LEVELS_DATA.collections[0];
    if (!firstCol || !firstCol.levels || !firstCol.levels.length) {
      alert("Pas encore de niveaux publi√©s. Utilise le Builder pour en cr√©er.");
      return;
    }
    const lvl = firstCol.levels[0];
    startGame(firstCol.id, lvl.id);
  });

  btnContinue.addEventListener("click", () => {
    const last=loadLastPlayed();
    if (!last) return;
    startGame(last.collectionId,last.levelId);
  });

  // =========================
  // COLLECTIONS
  // =========================
  const collectionsListEl = document.getElementById("collectionsList");
  document.getElementById("back-from-collections").addEventListener("click", () => {
    showScreen("home");
  });

  function buildCollectionsList() {
    collectionsListEl.innerHTML = "";
    if (!LEVELS_DATA.collections.length) {
      const div=document.createElement("div");
      div.className="smallText";
      div.textContent="Aucune collection pour l‚Äôinstant. Publie un niveau depuis le Builder.";
      collectionsListEl.appendChild(div);
      return;
    }
    LEVELS_DATA.collections.forEach(col => {
      const card=document.createElement("div");
      card.className="collectionCard";

      const thumb=document.createElement("div");
      thumb.className="collectionThumb";
      thumb.textContent=col.emoji || "üé®";

      const info=document.createElement("div");
      info.className="collectionInfo";

      const name=document.createElement("div");
      name.className="collectionName";
      name.textContent=col.name;

      const meta=document.createElement("div");
      meta.className="collectionMeta";
      const completedLevels = (col.levels||[]).filter(l=>isLevelCompleted(l.id)).length;
      meta.textContent = `${completedLevels}/${(col.levels||[]).length} compl√©t√©es`;

      info.appendChild(name);
      info.appendChild(meta);

      const right=document.createElement("div");
      right.style.fontSize="11px";
      right.style.color="#777";
      right.textContent=">";

      card.appendChild(thumb);
      card.appendChild(info);
      card.appendChild(right);

      card.addEventListener("click", () => {
        openCollection(col.id);
      });

      collectionsListEl.appendChild(card);
    });
  }

  // =========================
  // LEVELS SCREEN
  // =========================
  const levelsTitleEl=document.getElementById("levelsTitle");
  const levelsSubtitleEl=document.getElementById("levelsSubtitle");
  const levelsGridEl=document.getElementById("levelsGrid");
  let currentCollection = null;

  document.getElementById("back-from-levels").addEventListener("click", () => {
    showScreen("collections");
  });

  function openCollection(collectionId) {
    currentCollection = LEVELS_DATA.collections.find(c=>c.id===collectionId);
    if (!currentCollection) return;
    levelsTitleEl.textContent = currentCollection.name;
    levelsSubtitleEl.textContent = `${(currentCollection.levels||[]).length} images`;

    buildLevelsGrid(currentCollection);
    showScreen("levels");
  }

  function buildLevelsGrid(collection) {
    levelsGridEl.innerHTML = "";
    const levels = collection.levels || [];
    if (!levels.length) {
      const div=document.createElement("div");
      div.className="smallText";
      div.textContent="Aucun niveau dans cette collection.";
      levelsGridEl.appendChild(div);
      return;
    }

    levels.forEach((lvl, index) => {
      const card=document.createElement("div");
      card.className="levelCard";

      const thumb=document.createElement("div");
      thumb.className="levelThumb";
      thumb.textContent=lvl.title || lvl.id;

      const title=document.createElement("div");
      title.className="levelTitle";
      title.textContent=`#${index+1}`;

      const status=document.createElement("div");
      status.className="levelStatus";

      const progressData = loadLevelProgressData(collection.id, lvl.id);
      let percent = 0;
      if (progressData && typeof progressData.percent === "number") {
        percent = progressData.percent;
      } else if (isLevelCompleted(lvl.id)) {
        percent = 100;
      }

      const completed = isLevelCompleted(lvl.id) || (percent >= 100);

      if (completed) {
        status.textContent = `Termin√© ‚úì (${percent || 100}%)`;
        thumb.textContent = "";
        const canvas = document.createElement("canvas");
        canvas.width = 70;
        canvas.height = 70;
        canvas.className = "levelThumbCanvas";
        thumb.appendChild(canvas);
        drawLevelThumbnail(canvas, collection.id, lvl.id);
      } else {
        if (percent > 0) {
          status.textContent = `${percent}% compl√©t√©`;
        } else {
          status.textContent = "Non commenc√©";
        }
      }

      card.appendChild(thumb);
      card.appendChild(title);
      card.appendChild(status);

      card.addEventListener("click", () => {
        startGame(collection.id, lvl.id);
      });

      levelsGridEl.appendChild(card);
    });
  }

  async function drawLevelThumbnail(canvas, collectionId, levelId) {
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    try {
      const base = `levels/${collectionId}/${levelId}`;
      const [paletteRes, gridRes] = await Promise.all([
        fetch(base + "_palette.json"),
        fetch(base + "_grid.json"),
      ]);
      if (!paletteRes.ok || !gridRes.ok) return;
      const palette = await paletteRes.json();
      const grid = await gridRes.json();
      const size = grid.length;
      const cellSize = canvas.width / size;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const idx = grid[y][x];
          const col = palette[idx];
          if (!col) continue;
          ctx.fillStyle = `rgb(${col.r},${col.g},${col.b})`;
          ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
      }
    } catch (e) {
      console.warn("drawLevelThumbnail error", e);
    }
  }

  // =========================
  // GAME + SCRATCH
  // =========================
  let lastScratchX = null;
  let lastScratchY = null;
  let lastScratchTime = null;
  let needsSave = false;

  const backFromGame = document.getElementById("back-from-game");
  const gameTitleEl = document.getElementById("gameTitle");
  const gameSubtitleEl = document.getElementById("gameSubtitle");
  const gameProgressPercentEl = document.getElementById("gameProgressPercent");
  const gameRemainingEl = document.getElementById("gameRemaining");
  const gameCanvas = document.getElementById("gameCanvas");
  const gameCanvasScratch = document.getElementById("gameCanvasScratch");
  const ctxImg = gameCanvas.getContext("2d");
  const ctxScratch = gameCanvasScratch.getContext("2d");
  const gamePaletteRow = document.getElementById("gamePaletteRow");
  const gameBrushSlider = document.getElementById("gameBrushSlider");
  const gameBrushVal = document.getElementById("gameBrushVal");

  let currentGame = {
    collectionId: null,
    levelId: null,
    size: 0,
    grid: [],
    baseGrid: [],
    palette: [],
    remainingPerColor: [],
    totalCells: 0,
    revealed: 0,
    brushSize: 3,
    activeColorIndex: null,
    completed: false
  };

  backFromGame.addEventListener("click", () => {
    refreshGlobalProgressUI();
    if (currentCollection) {
      buildLevelsGrid(currentCollection);
      showScreen("levels");
    } else {
      showScreen("collections");
    }
  });

  gameBrushSlider.addEventListener("input", () => {
    currentGame.brushSize = parseInt(gameBrushSlider.value,10);
    gameBrushVal.textContent = currentGame.brushSize;
  });

  async function startGame(collectionId, levelId) {
    const col = LEVELS_DATA.collections.find(c=>c.id===collectionId);
    if (!col) {
      alert("Collection introuvable.");
      return;
    }
    const lvl = (col.levels||[]).find(l=>l.id===levelId);
    if (!lvl) {
      alert("Niveau introuvable dans cette collection.");
      return;
    }

    currentGame.collectionId = collectionId;
    currentGame.levelId = levelId;
    currentGame.brushSize = parseInt(gameBrushSlider.value,10);
    currentGame.completed = false;

    saveLastPlayed(collectionId, levelId);
    refreshContinueButton();

    gameTitleEl.textContent = lvl.title || lvl.id;
    gameSubtitleEl.textContent = col.name;

    await loadLevelDataFromServer(collectionId, levelId);
    showScreen("game");
  }

  function computeCountsFromGrid(grid, paletteLength) {
    const counts = new Array(paletteLength).fill(0);
    let revealed = 0;
    const size = grid.length;
    for (let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        const v = grid[y][x];
        if (v === -1) {
          revealed++;
        } else if (v>=0 && v<paletteLength) {
          counts[v]++;
        }
      }
    }
    return {counts,revealed};
  }

  async function loadLevelDataFromServer(collectionId, levelId) {
    try {
      const base = `levels/${collectionId}/${levelId}`;
      const [metaRes, paletteRes, gridRes] = await Promise.all([
        fetch(base + "_meta.json"),
        fetch(base + "_palette.json"),
        fetch(base + "_grid.json"),
      ]);
      if (!metaRes.ok || !paletteRes.ok || !gridRes.ok) {
        throw new Error("Erreur chargement fichiers de niveau");
      }
      const meta = await metaRes.json();
      const palette = await paletteRes.json();
      const grid = await gridRes.json();

      currentGame.size = meta.size || grid.length;
      currentGame.baseGrid = grid;
      currentGame.palette = palette;
      currentGame.totalCells = currentGame.size * currentGame.size;

      const saved = loadLevelProgressData(collectionId, levelId);

      if (saved && saved.grid &&
          Array.isArray(saved.grid) &&
          saved.grid.length === grid.length &&
          saved.grid[0].length === grid[0].length) {
        currentGame.grid = saved.grid;
        const cc = computeCountsFromGrid(saved.grid, palette.length);
        currentGame.remainingPerColor = cc.counts;
        currentGame.revealed = cc.revealed;
        currentGame.completed = !!saved.completed || (cc.revealed >= currentGame.totalCells);
      } else {
        currentGame.grid = grid.map(row => row.slice());
        const cc = computeCountsFromGrid(currentGame.grid, palette.length);
        currentGame.remainingPerColor = cc.counts;
        currentGame.revealed = cc.revealed;
        currentGame.completed = (currentGame.revealed >= currentGame.totalCells);
      }

      // Dessiner l'image finale sous la couche √† gratter (toujours √† partir de la grille d'origine)
      ctxImg.clearRect(0,0,gameCanvas.width,gameCanvas.height);
      const cellSize = gameCanvas.width / currentGame.size;
      for (let y = 0; y < currentGame.size; y++) {
        for (let x = 0; x < currentGame.size; x++) {
          const idxCell = currentGame.baseGrid[y][x];
          const col = currentGame.palette[idxCell];
          ctxImg.fillStyle = `rgb(${col.r},${col.g},${col.b})`;
          ctxImg.fillRect(
            x * cellSize,
            y * cellSize,
            Math.ceil(cellSize),
            Math.ceil(cellSize)
          );
        }
      }

      // Couche scratch uniforme au-dessus
      ctxScratch.clearRect(0,0,gameCanvas.width,gameCanvas.height);
      ctxScratch.globalCompositeOperation = "source-over";
      ctxScratch.globalAlpha = 1;
      ctxScratch.fillStyle = "#000";
      ctxScratch.fillRect(0,0,gameCanvas.width,gameCanvas.height);
      ctxScratch.globalAlpha = 0.75;
      ctxScratch.fillStyle = "#bbb";
      ctxScratch.fillRect(0,0,gameCanvas.width,gameCanvas.height);
      ctxScratch.globalAlpha = 1;
      ctxScratch.globalCompositeOperation = "source-over";

      // R√©-appliquer le grattage existant si sauvegarde
      if (currentGame.grid) {
        reapplyScratchFromGrid(currentGame.grid, cellSize);
      }
      // Si le niveau est enti√®rement termin√© ‚Üí retirer totalement la couche scratch
      if (currentGame.completed) {
        ctxScratch.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
      }

      buildGamePalette();
      updateGameUI();
      refreshPaletteCounters();
      needsSave = false;

    } catch (e) {
      console.error(e);
      alert("Impossible de charger ce niveau.\nV√©rifie qu'il a √©t√© publi√© correctement.");
    }
  }

  // =========================
  // PALETTE
  // =========================
  function refreshPaletteCounters() {
    const dots = document.querySelectorAll('#gamePaletteRow .dot');
    dots.forEach(dot => {
      const idx = parseInt(dot.dataset.colorIndex, 10);
      const badge = dot.querySelector('.dotCount');
      if (!isNaN(idx) && badge) {
        badge.textContent = currentGame.remainingPerColor[idx] || 0;
      }
    });
  }

  function setActiveColor(idx) {
    currentGame.activeColorIndex = idx;
    document.querySelectorAll("#gamePaletteRow .dot").forEach(d=>d.classList.remove("active"));

    if (idx == null || isNaN(idx)) {
      updateGameUI();
      return;
    }
    const dot = document.querySelector('#gamePaletteRow .dot[data-color-index="'+idx+'"]');
    if (dot) {
      dot.classList.add("active");
    }
    updateGameUI();
  }

  // Quand une couleur est compl√®tement utilis√©e (0 restants)
  function handleColorDepleted(colorIndex) {
    if (currentGame.remainingPerColor[colorIndex] < 0) {
      currentGame.remainingPerColor[colorIndex] = 0;
    }

    // haptic "color finie"
    triggerHaptic("medium");

// üîä son pastille vide
  try { sndDone.currentTime = 0; sndDone.play(); } catch(e){}

    // animer + retirer la pastille visuelle
    const dot = document.querySelector('#gamePaletteRow .dot[data-color-index="'+colorIndex+'"]');
    if (dot) {
      dot.classList.add("disappearing");
      setTimeout(() => {
        if (dot && dot.parentNode) {
          dot.parentNode.removeChild(dot);
        }
      }, 550);
    }

    // si c'√©tait la couleur active ‚Üí passer √† une autre
    if (currentGame.activeColorIndex === colorIndex) {
      let newIdx = null;
      for (let i = colorIndex + 1; i < currentGame.remainingPerColor.length; i++) {
        if (currentGame.remainingPerColor[i] > 0) { newIdx = i; break; }
      }
      if (newIdx === null) {
        for (let i = colorIndex - 1; i >= 0; i--) {
          if (currentGame.remainingPerColor[i] > 0) { newIdx = i; break; }
        }
      }
      if (newIdx !== null) {
        setActiveColor(newIdx);
      } else {
        currentGame.activeColorIndex = null;
        updateGameUI();
      }
    }

    refreshPaletteCounters();
  }

  function buildGamePalette() {
    gamePaletteRow.innerHTML = "";
    currentGame.activeColorIndex = null;

    currentGame.palette.forEach((c,i) => {
      const remaining = currentGame.remainingPerColor[i] || 0;
      if (remaining <= 0) return; // üî• ne pas recr√©er les couleurs finies

      const dot = document.createElement("div");
      dot.className="dot";
      dot.style.background=`rgb(${c.r},${c.g},${c.b})`;
      dot.dataset.colorIndex = i.toString();

      const count=document.createElement('div');
      count.className='dotCount';
      dot.appendChild(count);

      dot.addEventListener("click", () => {
        setActiveColor(i);
        refreshPaletteCounters();
      });

      gamePaletteRow.appendChild(dot);
    });

    // activer par d√©faut la premi√®re couleur qui a encore des cases
    let firstIdx = null;
    for (let i = 0; i < currentGame.remainingPerColor.length; i++) {
      if (currentGame.remainingPerColor[i] > 0) {
        firstIdx = i;
        break;
      }
    }
    if (firstIdx !== null) {
      setActiveColor(firstIdx);
    } else {
      currentGame.activeColorIndex = null;
      updateGameUI();
    }

    refreshPaletteCounters();
  }

  function updateGameUI() {
    const total = currentGame.totalCells;
    const revealed = currentGame.revealed;
    const p = total>0 ? Math.floor((revealed/total)*100) : 0;
    gameProgressPercentEl.textContent = p + "%";

    if (currentGame.activeColorIndex==null) {
      gameRemainingEl.textContent = "0";
    } else {
      gameRemainingEl.textContent = currentGame.remainingPerColor[currentGame.activeColorIndex] || 0;
    }
  }

  // =========================
  // SCRATCH
  // =========================
  let isMouseDown = false;
  let isTouching = false;

  gameCanvasScratch.addEventListener("mousedown", (e)=>{
    isMouseDown=true;
    triggerHaptic("light");   // feedback au contact
    scratchAtEvent(e.clientX,e.clientY);
  });
  document.addEventListener("mouseup", ()=>{
    isMouseDown=false;
    if (needsSave) {
      saveCurrentProgress();
      needsSave = false;
    }
  });
  gameCanvasScratch.addEventListener("mousemove", (e)=>{
    if(!isMouseDown) return;
    scratchAtEvent(e.clientX,e.clientY);
  });

  gameCanvasScratch.addEventListener("touchstart", (e)=>{
    isTouching=true;
    triggerHaptic("light");   // feedback au contact tactile
    e.preventDefault();
    const t=e.touches[0];
    scratchAtEvent(t.clientX,t.clientY);
  }, {passive:false});
  gameCanvasScratch.addEventListener("touchmove",(e)=>{
    if(!isTouching) return;
    e.preventDefault();
    const t=e.touches[0];
    scratchAtEvent(t.clientX,t.clientY);
  }, {passive:false});
  gameCanvasScratch.addEventListener("touchend",()=>{
    isTouching=false;
    if (needsSave) {
      saveCurrentProgress();
      needsSave = false;
    }
  });
  gameCanvasScratch.addEventListener("touchcancel",()=>{
    isTouching=false;
    if (needsSave) {
      saveCurrentProgress();
      needsSave = false;
    }
  });

  function scratchAtEvent(clientX,clientY) {
    if (currentGame.activeColorIndex==null) return;
    const rect = gameCanvas.getBoundingClientRect();
    const px = clientX - rect.left;
    const py = clientY - rect.top;

    const scaleX = gameCanvas.width / rect.width;
    const scaleY = gameCanvas.height / rect.height;
    const cx = px * scaleX;
    const cy = py * scaleY;

    const size = currentGame.size;
    const cellSize = gameCanvas.width / size;

    const gx = Math.floor(cx / cellSize);
    const gy = Math.floor(cy / cellSize);

    const now = performance.now();
    let vx = 0, vy = 0;
    if (lastScratchX !== null) {
      const dt = now - lastScratchTime;
      if (dt > 0) {
        vx = (cx - lastScratchX) / dt;
        vy = (cy - lastScratchY) / dt;
      }
    }
    lastScratchX = cx;
    lastScratchY = cy;
    lastScratchTime = now;

    scratchAtGrid(gx,gy,vx,vy);
  }

  function eraseOnScratch(x, y, r, vx, vy) {
    const speed = Math.sqrt(vx*vx + vy*vy);
    const jitter = Math.min(speed * 0.15, 1.2);
    const jx = (Math.random() - 0.5) * jitter;
    const jy = (Math.random() - 0.5) * jitter;

    ctxScratch.save();
    ctxScratch.globalCompositeOperation = "destination-out";
    ctxScratch.beginPath();
    ctxScratch.arc(x + jx, y + jy, r, 0, Math.PI * 2);
    ctxScratch.fill();
    ctxScratch.restore();
  }

  function scratchAtGrid(cx,cy,vx,vy) {
    const size = currentGame.size;
    const active = currentGame.activeColorIndex;
    const brush = currentGame.brushSize;
    const cellSize = gameCanvas.width / size;

    if (active == null) return;

    let anyChange = false;

    for (let dy=-brush; dy<=brush; dy++){
      for (let dx=-brush; dx<=brush; dx++){
        const X = cx+dx;
        const Y = cy+dy;
        if (X<0||Y<0||X>=size||Y>=size) continue;

        const val = currentGame.grid[Y][X];
        if (val !== active) continue;

        if (currentGame.grid[Y][X] !== -1) {
          currentGame.grid[Y][X] = -1;
          currentGame.revealed++;
          anyChange = true;
          if (currentGame.remainingPerColor[active] > 0) {
            currentGame.remainingPerColor[active]--;
            if (currentGame.remainingPerColor[active] === 0) {
              handleColorDepleted(active);
            }
          }
        }

        const centerX = X*cellSize + cellSize/2;
        const centerY = Y*cellSize + cellSize/2;
        eraseOnScratch(centerX, centerY, cellSize*0.75, vx, vy);
      }
    }

    if (anyChange) {
  needsSave = true;

  // üîä jouer le son de scratch (sound_scratch.mp3)
  playScratchSound();
}

    updateGameUI();
    refreshPaletteCounters();
    checkCompletion();
  }

  function reapplyScratchFromGrid(gridData, cellSize) {
    ctxScratch.save();
    ctxScratch.globalCompositeOperation = "destination-out";
    for (let y = 0; y < currentGame.size; y++) {
      for (let x = 0; x < currentGame.size; x++) {
        if (gridData[y][x] === -1) {
          const centerX = x * cellSize + cellSize / 2;
          const centerY = y * cellSize + cellSize / 2;
          ctxScratch.beginPath();
          ctxScratch.arc(centerX, centerY, cellSize * 0.75, 0, Math.PI * 2);
          ctxScratch.fill();
        }
      }
    }
    ctxScratch.restore();
  }

  function saveCurrentProgress() {
    if (!currentGame.collectionId || !currentGame.levelId) return;
    const total = currentGame.totalCells || (currentGame.size * currentGame.size) || 0;
    const revealed = currentGame.revealed || 0;
    const percent = total > 0 ? Math.floor((revealed / total) * 100) : 0;
    const payload = {
      collectionId: currentGame.collectionId,
      levelId: currentGame.levelId,
      revealed,
      total,
      percent,
      completed: currentGame.completed,
      grid: currentGame.grid
    };
    saveLevelProgressData(payload);
  }

  function checkCompletion() {
    if (currentGame.completed) return;
    if (currentGame.revealed >= currentGame.totalCells) {
      currentGame.completed = true;
      markLevelCompleted(currentGame.levelId);
      refreshGlobalProgressUI();
      saveCurrentProgress();
      triggerHaptic("heavy"); // vibration plus forte √† la compl√©tion
      alert("Image compl√©t√©e ! üéâ");
    }
  }

  // =========================
  // INIT
  // =========================
  async function initGame() {
    await loadLevelsConfig();
    refreshGlobalProgressUI();
    refreshContinueButton();
  }
  initGame();

  // Sound handlers (facultatif, √† brancher si tu veux)
    const endOverlay = document.getElementById("endOverlay");
  const btnEndBack = document.getElementById("btnEndBack");

  
  if (btnEndBack) btnEndBack.addEventListener("click", ()=>{ endOverlay.style.display="none"; showScreen("levels"); });
</script>



<div id="endOverlay" style="display:none; position:fixed; inset:0;
  background:rgba(0,0,0,0.5);  align-items:center;
  justify-content:center; z-index:999;">
  <div style="background:white; border-radius:20px; padding:16px; width:80%; max-width:320px; text-align:center;">
    <div style="font-weight:600; margin-bottom:8px;">Image compl√©t√©e ! üéâ</div>
    <button id="btnEndBack" class="btn btnPrimary">Retour</button>
  </div>
</div>
 
<script>
  // Enregistrement du Service Worker pour PWA
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker
        .register("sw.js")
        .catch(err => console.warn("SW registration failed", err));
    });
  }
</script>


<!-- Added audio elements -->
<audio id="sndSelect" src="sounds/sound_pop_select.mp3"></audio>
<audio id="sndDone" src="sounds/sound_pop_done.mp3"></audio>
<audio id="sndScratch" src="sounds/sound_scratch.mp3"></audio>

<script>
// Added sound handling
const sndSelect = document.getElementById('sndSelect');
const sndDone = document.getElementById('sndDone');
const sndScratch = document.getElementById('sndScratch');

let lastScratchSound = 0;
function playScratchSound() {
  const now = performance.now();
  if (now - lastScratchSound > 80) {
    try { sndScratch.currentTime = 0; sndScratch.play(); } catch(e){}
    lastScratchSound = now;
  }
}

// Hook selection
document.addEventListener('click', (e)=>{
  if(e.target.classList.contains('dot')) {
    try { sndSelect.currentTime = 0; sndSelect.play(); } catch(e){}
  }
});

// To be integrated in scratch logic: call playScratchSound() when valid
</script>

</body>
</html>
